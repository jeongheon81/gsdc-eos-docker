---
- block:
  - set_fact:
      shiped_files: []
      template_files:
      - { container_path: "/etc/heimdal-kadmind.acl", host_dir: ".", host_file: "heimdal-kadmind.acl", template_file: "heimdal-kadmind.acl.j2", owner: "root", group: "root", mode: "0600" }
      - { container_path: "/etc/heimdal-kdc.conf", host_dir: ".", host_file: "heimdal-kdc.conf", template_file: "heimdal-kdc.conf.j2", owner: "root", group: "root", mode: "0600" }
      - { container_path: "/etc/heimdal-slaves", host_dir: ".", host_file: "heimdal-slaves", template_file: "heimdal-slaves.j2", owner: "root", group: "root", mode: "0600" }
      - { container_path: "/etc/krb5.conf", host_dir: ".", host_file: "krb5.conf", template_file: "krb5.conf.j2", owner: "root", group: "root", mode: "0644" }
      - { container_path: "/kdc.sh", host_dir: ".", host_file: "kdc.sh", template_file: "kdc.sh.j2", owner: "root", group: "root", mode: "0755" }
      persistent_volumes:
      - { name: "roothome", dest: "/root" }
      - { name: "heimdal", dest: "/var/heimdal" }
      - { name: "log", dest: "/var/log/heimdal" }
      eos_componets: "{{ containers.eos_krb }}"

  - name: Set empty initialization informaions variable
    set_fact:
      initialization_infos: []
      need_shiped_files: {}

  - name: Init need_shiped_files flag
    set_fact:
      need_shiped_files: "{{ need_shiped_files | combine({ item.name: 'False'|bool }) }}"
    loop: "{{ eos_componets }}"

  - name: Check initialized holder
    stat: path=/etc/eos-docker/{{ eos_componet.name }}/INITIALIZED
    register: initialized_holder_stats
    loop: "{{ eos_componets }}"
    loop_control:
      loop_var: eos_componet

  - name: Build initialization informaions of each container
    set_fact:
      initialization_infos: "{{ initialization_infos + [ { 'eos_componet': item.eos_componet, 'is_initialized': item.stat.exists } ] }}"
    loop: "{{ initialized_holder_stats.results }}"

  - name: Create shiped and template file directory
    file:
      path: "/etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1].host_dir }}/"
      state: directory
      mode: u=rwX,g=rX,o=rX
      recurse: yes
    when: not item[0].is_initialized
    loop: "{{ initialization_infos|product(shiped_files + template_files)|list }}"

  - name: Check shiped files
    stat: path=/etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1].host_dir }}/{{ item[1].host_file }}
    register: shiped_files_stats
    loop: "{{ initialization_infos|product(shiped_files)|list }}"

  - name: Build need_shiped_files
    set_fact:
      need_shiped_files: "{{ need_shiped_files | combine({ item.item[0].eos_componet.name: 'True'|bool }) }}"
    when: not item.stat.exists
    loop: "{{ shiped_files_stats.results }}"

  - name: Start container for shiped files
    docker_container:
      name: "{{ item.eos_componet.name }}"
      image: "{{ item.eos_componet.image }}"
      state: started
      recreate: yes
      interactive: yes
      tty: yes
      hostname: "{{ item.eos_componet.name }}.{{ item.eos_componet.domain }}"
    when: not item.is_initialized or need_shiped_files[item.eos_componet.name]
    loop: "{{ initialization_infos }}"

  - name: Copy default shiped files
    shell: if ! {{ item[0].is_initialized|string|lower }} ||  [ ! -e /etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1].host_dir }}/{{ item[1].host_file }} ] ; then docker cp {{ item[0].eos_componet.name }}:{{ item[1].container_path }} /etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1].host_dir }}/{{ item[1].host_file }} && echo changed; else echo skipped; fi
    args:
      executable: /bin/bash
    register: copy_command_result
    changed_when: copy_command_result.stdout_lines|length > 0 and copy_command_result.stdout_lines[-1] == 'changed'
    loop: "{{ initialization_infos|product(shiped_files)|list }}"

  - name: Stop container for shiped files
    docker_container:
      name: "{{ item.eos_componet.name }}"
      state: absent
    when: not item.is_initialized or need_shiped_files[item.eos_componet.name]
    loop: "{{ initialization_infos }}"

  - name: Create template files
    template: src={{ item[1].template_file }} dest=/etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1].host_dir }}/{{ item[1].host_file }} owner={{ item[1].owner }} group={{ item[1].group }} mode={{ item[1].mode }} force={{ not item[0].is_initialized }}
    loop: "{{ initialization_infos|product(template_files)|list }}"

  - name: Create initialized holder
    file:
      path: /etc/eos-docker/{{ item.eos_componet.name }}/INITIALIZED
      state: touch
    when: not item.is_initialized
    loop: "{{ initialization_infos }}"

  - name: Create a local volume
    docker_volume:
      name: "{{ item[0].name }}_{{ item[1].name }}"
    loop: "{{ eos_componets|product(persistent_volumes)|list }}"

  - name: Create a nfs volume
    docker_volume:
      name: "{{ item[0].name }}_{{ item[1].name }}"
      driver_options:
        type: nfs
        device: "{{ item[1].device }}"
        o: "{{ item[1].options }}"
    loop: "{{ eos_componets|default([{}])|subelements('nfs_volumes', skip_missing=True) }}"

  - name: Set empty container_volumes variable
    set_fact:
      container_volumes: {}

  - name: Build empty volume list of each container
    set_fact:
      container_volumes: "{{ container_volumes | combine( { item.name: [] } ) }}"
    loop: "{{ eos_componets }}"

  - name: Build container volume list with shiped_files and template_files
    set_fact:
      container_volumes: "{{ container_volumes | combine({ item[0].name: container_volumes[item[0].name] + [ '/etc/eos-docker/' + item[0].name + '/' + item[1].host_dir + '/' + item[1].host_file + ':' + item[1].container_path ] }) }}"
    loop: "{{ eos_componets|product(shiped_files+template_files)|list }}"

  - name: Build container volume list with persistent_volumes
    set_fact:
      container_volumes: "{{ container_volumes | combine({ item[0].name: container_volumes[item[0].name] + [ item[0].name + '_' + item[1].name + ':' + item[1].dest ] }) }}"
    loop: "{{ eos_componets|product(persistent_volumes)|list }}"

  - name: Build container volume list with nfs_volumes
    set_fact:
      container_volumes: "{{ container_volumes | combine({ item[0].name: container_volumes[item[0].name] + [ item[0].name + '_' + item[1].name + ':' + item[1].dest ] }) }}"
    loop: "{{ eos_componets|default([{}])|subelements('nfs_volumes', skip_missing=True) }}"

  - name: Start container
    docker_container:
      name: "{{ item.name }}"
      image: "{{ item.image }}"
      state: started
      interactive: yes
      tty: yes
      hostname: "{{ item.name }}.{{ item.domain }}"
      purge_networks: yes
      networks:
      - name: "{{ item.network }}"
        ipv4_address: "{{ item.ipv4_address }}"
        aliases: "{{ [ item.name ] + item.network_aliases|default([]) }}"
      volumes: "{{ container_volumes[item.name] }}"
      etc_hosts: "{{ item.etc_hosts }}"
    register: container_start_results
    loop: "{{ eos_componets }}"

  - name: Start service
    shell: docker exec -i {{ item.item.name }} /kdc.sh
    when: item.changed
    loop: "{{ container_start_results.results }}"

  - name: Copy keytab files
    shell: if ! {{ item[0].is_initialized|string|lower }} || [ ! -e /etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1] }}.keytab ] ; then docker cp {{ item[0].eos_componet.name }}:/root/{{ item[1] }}.keytab /etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1] }}.keytab && echo changed; else echo skipped; fi
    args:
      executable: /bin/bash
    register: copy_command_result
    changed_when: copy_command_result.stdout_lines|length > 0 and copy_command_result.stdout_lines[-1] == 'changed'
    loop: "{{ initialization_infos|product(eos_mgm_masters + [ eos_admin_user ])|list }}"

  - name: Fetch keytab files
    fetch:
      src: "/etc/eos-docker/{{ item[0].eos_componet.name }}/{{ item[1] }}.keytab"
      dest: "tmp/{{ item[0].eos_componet.name }}.{{ item[0].eos_componet.domain }}_{{ item[1] }}.keytab"
      flat: yes
    loop: "{{ initialization_infos|product(eos_mgm_masters + [ eos_admin_user ])|list }}"

  when: containers is defined and containers.eos_krb is defined
